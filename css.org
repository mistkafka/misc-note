#+TITLE: CSS 学习笔记

* 前言
  个人的CSS水平实在太烂了，我决定重新梳理一遍css的知识，同时进行 =daily css production= 。梳理知识的目的在于找到更好的 =知识树= ，而实践的目的在于css技能的 =保持活性= 。

* Element Selector
** 官方的Attribute Selector的分类
   我觉得[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Attribute_selectors][MDN]]/[[https://www.w3.org/TR/selectors-3/#attribute-selectors][Selector-3]]对 =Attribute Selector= 分类很合理 大致可以分层两类：

   1. Attribute presence and value selector - 切确字符类

   2. Substring matching attribute selectors - 字符子串匹配类

   第一种用来匹配切确的字符（属性），而第二类有点像正则表达式（但又不是）用来匹配子串。

*** Attribute presence and value selector
    这个分类的属性选择器有：

    - [att] :: =存在= att这个属性的元素
    - [att=val] :: 存在att这个属性，并且值 =为= val的元素
    - [att~=val] :: 存在att这个属性，并且值是由空白字符分割开的一串单词， =其中一个= 单词是val的元素

*** Substring matching attribute selector
    - [att^=val] :: 存在att这个属性，并且值是以val =开头= 的元素，这很RegExp
    - [att$=val] :: 存在att这个属性，并且值是以val =结尾= 的元素，这很RegExp
    - [att*=val] :: 存在att这个属性，并且值 =存在子串是val= 的元素，这也还算比较RegExp

** 我的Attribute Selector分类
   在记录上面的“官方”分类的时候，我故意遗漏了 =[att|=val]= 属性选择器，这是因为我对官方的分类方式不是很赞同。

*** 特殊的[att|=val] selector
    先说说其定义：存在att这个属性，并且值是以val开头 =或以val-= 开头的元素，这不是那么RegExp。初看很容易让人以为这个选择器跟 =[att^=val]= 没有什么区别，但令人猝不及防的是，它夹带了私货—— =“或以val-”开头= ，这样一条额外的定义。
    W3的[[https://www.w3.org/TR/selectors-3/#attribute-selectors][Selector Level 3]]文档将其划分为第一类，Attribute presence and value selector。而MDN的[[https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Attribute_selectors][Attribute Selector]]文档则将其划分为第二类，Substring matching attribute selector。说到底还是这个选择器太让人迷惑了，为什么有了 =[att^=val]= 还需要一个 =[att|=val]= ？
    简单的说，我个人认为属性选择器需要第三个分类：特殊属性选择器。它们因为特殊的目的、特殊的使用场景而存在。同时，我个人认为， =[att|=val]= 跟 =[att~=val]= 这两个选择器都应该分属此类。
    从官方的定义，我们很容易知道这个属性选择器其实是为了匹配语言用的，比如我们希望语言是中文的时候应用某些特殊的css。但是中文的code有几种？从这份[[http://www.lingoes.cn/zh/translator/langcode.htm][语言代码表]]中可以看出有6种。那么如果没有 =[att|=val]= 这个选择器，我们需要这么写：

    #+BEGIN_SRC css

      [lang="zh"], [lang^="zh-"] {
          /* ba la ba la */
      }

    #+END_SRC

    个人推测估计组委会的人觉得，这样太麻烦太ugly了，于是创造了 =[att|=val]= 这种“语法糖”来“fix”这种繁琐的操作。然而，这种少几个字符的改进，却给我们带来了认知困惑，真是得不偿失！个人认为，还不如单独为语言选择创造一种选择器好了，把这种特殊“具名化”，让人一眼就知道其目的性，反倒不容易跟那些“原子性”的属性选择器混淆。 =:lang()= 这个伪类选择器貌似是用来弥补这种认知bug的，但是要小心它们之间是不一样的，详见[[https://www.w3.org/TR/selectors-3/#lang-pseudo][:lang伪类]]。

    个人再作进一步推测，为什么 =[att|=val]= 这个选择器的标识符是竖线"|"。我估计，这是因为正则表达式里，“或” 是用 "|" 表示的。希望对记忆这个选择器的“样子”有帮助。

*** 对[att~=val]存在目的的推测
    =[att|=val]= 的目的是匹配lang属性，那么 =[att~=val]= 的目的又是什么呢？它真的跟 =[att*=val]= 很像啊！不是吗？为什么它也被划分在第一类属性选择器里？
    说真的，我没有什么头绪。唯一能想到的，就是匹配class。我们可以用 =[att~=val]= 来模拟类选择器，大致如下：

    #+BEGIN_SRC css

      [class~="btn"] {
          /* 定义 */
      }

      .btn {
          /* 定义 */
      }
    #+END_SRC

    但是已经有了类选择器来，再造出这样一个选择器来略显多余。唯一的可能就是确实存在类似class属性的过滤需求，但是其属性名又不是class。当然，我目前没有想到。
*** 最终结果
    所以，我对属性选择器的最终分类为：

    1. 非类RegExp属性选择器 :: [att] [att=val]
    2. 类RegExp属性选择器 :: [att^=val] [att$=val] [att*=val]
    3. 特殊目的属性选择器 :: 语言属性选择器 [att|=val]，类名属性选择器 [att~=val]

    这样，我们就不用去纠结 =[att|=val]= 与 =[att^=val]= 的区别，以及 =[att~=val]= 与 =[att*=val]= 的区别了
** Pseudo-class and pseudo-element
   Pseudo-class以及pseudo-element与其它选择器有什么区别？我的理解是，pseudo-selector提供的能力，更像是原本只能由js来实现，而现在css进行了“原生实现”。它们讨论的，更多的是关于“状态”，而不是元素本身的DOM Tree结构。我有一种感觉，也许是错觉，那就是CSS3在选择器方面的“能力”扩展，基本都是在preudo-selector这个类别里扩展的。
   去讨论pseudo-class与pseudo-element的区别貌似没有什么意义（尤其是::selection也归类为pseudo-element之后），而且也不是重点。我觉得pseudo-class与pseudo-element的重点在于 =了解= 各个选择器的定义作用， =归类分组= 各个选择器以帮助记忆。我觉得，这个方面[[https://www.w3.org/TR/selectors-3/#pseudo-classes][《Selector Level 3》]]已经做得很好了！这里，无需再搬运过来。
   如果有什么值得记录，那应该就是还有一些零碎的容易混淆的点，可能需要特别去理清楚。这里就着重讨论这些吧！

*** :nth-child() vs :nth-of-type()
    =:nth-child()= 应该是很好理解的，就是“第几个子元素”的意思。然而，实际上并非那么简单！到底是哪些元素中的 =Tn+X= 个呢？我们直接上结果：

    - SelectorA:nth-child(Tn+X) :: 是从SelectorA所选中的元素所在的 =那一层的所有元素= 的Tn+X，同层计算。
    - SelectorA:nth-of-type(Tn+X) :: 是从SelectorA所选中的元素中的Tn+X，同层计算。

    同层计算是什么意思呢？先看代码：

    #+BEGIN_SRC web
      <style>
       .list>.list-item {
           background-color: red;
       }
      </style>

      <ul class="list" id="l1">
          <li class="list-item">abc</li>
          <li class="list-item">hehe</li>
          <li class="list-item">haha</li>
          <li class="list-item">keke</li>
          <hr class="list-dividline"/>
          <li class="list-item">lele</li>
      </ul>


      <ul class="list" id="l2">
          <li class="list-item">abc</li>
          <li class="list-item">hehe</li>
          <li class="list-item">haha</li>
          <li class="list-item">keke</li>
          <hr class="list-dividline"/>
          <li class="list-item">lele</li>
      </ul>
    #+END_SRC

    对于上述代码， ~.list>.list-item {}~ 匹配的是什么？是.list下的直接子元素.list-item。 ~#l1~ 下的 ~.list-item~ 为同一层，而 ~#l2~ 下的 ~.list-item~ 为另一层。每个层自己计算Tn+X，就是同层计算。
    你可以给选择器加上nth-child或者nth-of-type的伪类修饰，来看看会有什么结果。我以前以为，只要看看两个不同的结果就很好记忆它们之间的区别了！然而，时间一长就又会忘记。css这样“死记硬背”的东西，实在让人抓狂。于是，我想到了一种转换记忆的方式。那就是用代码来记忆二者的区别。
    假设我们要实现浏览器的渲染引擎，让你来实现 =:nth-child()= 跟 =:nth-of-type()= 的逻辑，应该如何实现呢？我们这里不考虑上面所说的“层”的问题，假定一个选择器只会有一个层匹配。那么设，选择器原本匹配到的元素叫 ~candidateElemetns~，加上 =nth-child或nth-of-type= 修饰后匹配到的元素叫做 ~targetElements~，看如下js伪代码：

    #+BEGIN_SRC javascript

      /**
       ,* 获取某个原始选择器选中的元素
       ,*
       ,* @selector 原始选择器，指没有带伪类的选择器，如上文的'.list > .list-item'
       ,* @return 符合选择器的元素，这里假设都在同一层
       ,*/
      function getCandidateElements(selector) {
          // ...
      }

      /**
       ,* 根据周期规则，获取匹配到的元素的函数 
       ,*
       ,* @elements 元素数组
       ,* @rule 规则，如'2n+1', 或'2n+0' 这样
       ,* @return 符合规则的元素
       ,*/
      function getRoundMatchElements(elements, rule) {
          // ...
      }

      /**
       ,*  获取原始选择器:nth-of-type(rule)的元素
       ,*
       ,* @selector 原始选择器，指没有带伪类的选择器，如上文的'.list > .list-item'
       ,* @rule nth-of-type的规则，如'2n + 1'
       ,* @return 符合规则的元素
       ,*/
      function getNthOfTypeElements(selector, rule) {
          // 获取原始选择器匹配到的元素
          const candidateElements = getCandidateElements(selector);

          // 直接拿原始选择器匹配到的元素去作Tn+X的规则匹配
          const targetElements = getRoundMatchElements(candidateElements, rule);

          return targetElements;
      }


      /**
       ,*  获取原始选择器:nth-child(rule)的元素
       ,*
       ,* @selector 原始选择器，指没有带伪类的选择器，如上文的'.list > .list-item'
       ,* @rule nth-child的规则，如'2n + 1'
       ,* @return 符合规则的元素
       ,*/
      function getNthChildElements(selector, rule) {
          // 获取原始选择器匹配到的元素
          const candidateElements = getCandidateElements(selector);
          const candidateElementsSet = new Set(candidateElements); // 转换为set，备用

          // 获取candidateElemtn元素所在层的“所有”元素，包含自己
          const sidbingsElements = getSidbingsElements(candidateElements[0]);
          // 用那一层的“所有元素”，去作Tn+X的规则匹配，获取到匹配中的元素
          // 这是nth-child与nth-of-type的区别所在！匹配规则的范围不一样
          const matchRoundRuleElements = getRoundMatchElements(sidbingsElements, rule);

          // 最后，再从匹配到的元素中过滤出candidateElement，其结果就是targetElements
          const targetElements = matchRoundRuleElements.filter((element) => {
              return candidateElementsSet.has(element);
          });

          return targetElements;
      }
    #+END_SRC

    看完代码之后你会发现，其实 =nth-of-type= 是简单的，而 =nth-child= 的规则反而是复杂的。它们的共同点在于，匹配出来的元素都必须是原始selector选中的元素。不同点在于： =nth-of-type= 直接以原始selector选中的元素进行Tn+X的规则匹配，而 =nth-child= 则比较麻烦，它用的是元素所在层的所有元素进行规则匹配的。

*** Tn+X 的规则描述
    =:nth-child(Tn+X)= 的规则的描述能力还是算强大的。但是其规则是怎样的呢？W3c用了编程语法的方式描述出来，实在有点看不懂。我们将其描述为数学语言，可能会好一些。设，公式为： ~N(n)=Tn + X~，其中：
    1. N(n) 为公式的计算结果，表示表示第几个，为整数，且N(n) > 0
    2. T 重复周期，必须为整数（所以，可以为负数）；
    3. X 为起始偏移量，必须为整数，对结果N(n)有影响
    4. n必须为自然数，即 0, 1, 2, 3...
    满足上述条件的所有n的N(n)，即为要选择的元素。

    我们来解读几个：

    - xx:nth-child(7) :: T = 0, X = 7, n的可取值为整个自然数集，但是N(n)的结果集为 {7}，所以nth-child(7)就表示xx的第7个元素
    - xx:nth-child(2n + 1) :: T = 2, X = 1, n的可取值为整个自然数集，N(n)的结果集为 {1, 3, 5 ... 7}，也就是“奇自然数”，所以nth-child(2n + 1)就表示...
    - xx:nth-child(2n + 3) :: T = 2, X = 3，n的可取值为整个自然数集，N(n)的结果集为 {3, 5, ...7 }，也就是3以后包括3的“奇自然数”，所以nth-child...
    - xx:nth-child(-n + 3) :: T = -1, X = 3, n的可取值为{0, 1, 2}, N(n)的结果集为 {1, 2, 3}，所以nth-child:(-n + 3)....
    - xx:nth-child(n + 15) :: T = 1, X = 15, n的可取值为曾哥自然数集，N(n)的结果为 {15, 16, 17....}，所以nth-child
    - xx:nth-child(n + 3):nth-child(-n + 15) :: N(n)的结果集是 {3, 4, 5, 6...13, 14, 15}，为什么？下文解答

    对于最后一个选择器，如果分成 =xx:nth-child(n + 3)= 与=xx:nth-child(-n + 15)= 应该都是很容易解读。但是，合在一起之后呢？这样，我们现介绍一下css选择器的组合规则：

    1. css选择器在组合的时候，选择器之间“相连”表示“并且”，如 =.list-item.active= 表示有.list-item同时也有.active class的元素
    2. “单纯只有空格”表示“后代组合”，如 ~.list .list-item~ 表示祖代（可能是父元素，也可能是父元素的父元素）是.list的.list-item
    3. 用“>”连接，表示“之间子代”，如~.list > .list-item~，略

    所以，=xx:nth-child(n+3):nth-child(-n+15)= 表示的是并集。

    最后，再回过头来看Tn+X的规则，不知道是否有清晰一些？我觉得，即便记不住也没事，这种东西翻翻文档就很容易查到。最关键的是，要知道Tn+X的表示什么？它不是只能表示周期序列，它也能给这个周期序列加上范围限定。

*** :lang(zh) vs [lang="zh"]
    简单的说，~:lang(zh)~ 是当元素处于"zh"语系的时候会应用对应的css。特别注意：这时候此元素未必需要有[lang="zh"]这个属性。也就是说，如果只有body定义了lang属性，即 ~<body lang="zh">~ ，那么body下的所有元素都满足 ~:lang(zh)~ 下的规则。而 ~[lang="zh"]~ ，则只能匹配到 ~body~ 这个元素。

** Combinators and groups of selector
   选择器的组合与“组”（我不知道这个怎么翻译更好），上面其实已经讲到了，这里面似乎没有什么好讲的。这里，我能想到的讨论点，当然也是“超纲”的点，就是[[http://oocss.org][OOCSS]]这种方法论提倡少用“后代组合器”，即选择器尽量与特定的HTML结构无关，详见这篇[[http://bubkoo.com/2015/06/25/css-methodologies/][博客]]。
   关于CSS方法论，我想说的是，“尽信书，不如无书”吧！

** Calculating a selector's specificity
   如何计算一个选择器的“特殊性”？这一部分看下文档还是很简单的，但是这个权重有什么用呢？我觉得这个才是重点。简单来说，当有多条同一规则的css应用于同一元素时（比如，有3个选择器都分别定义了元素的 =color= 属性，到底采用谁的？），需要这个权重去判断到底采用哪一条规则。所以，这里会完整的讨论一下浏览器如何处理这个问题的。
   另外，当然也要讲一下如何计算css选择器的权重。从类比学习的角度出发，它的机制跟linux/unix里的文件权限有点类似。

*** Cascading order
    Cascading，指的是层叠样式规则，也就是css规则。官方称这个问题为“Cascading order”，大意应该是指css规则的采用顺序，见[[https://www.w3.org/TR/CSS22/cascade.html#cascade][W3C CSS2.2 -- Cascading]]的文档，说得很详细。下面，我就用自己的语言阐述一遍。
    W3C规定这个问题，有4个因素会影响到：

    1. css规则的 =来源= 。是浏览器默认定义？还是开发者定义的？还是用户定义的？官方分别称为，“user agent”，“author”，“user”(ps. 某些浏览器可能会支持用户定义自己的css。)
    2. css规则的 =重要性= 。css只有两中重要性等级，一种默认情况下的，称为“normal”；另一种是加了万恶的 =important!= 的，称为“important”;
    3. css规则对应选择器的 =特殊性= 。一会，我们会讲如何计算。
    4. css规则的定义 =顺序=。

    所以，四个因素是：来源，重要性，特殊性以及先后顺序。但是“来源”与“重要性”在这里却有一个“小插曲”，当我们只考虑二者的时候，按照W3C的说法，应该很容易得出这样的顺序表（越靠前越先采用）：

    | 来源       | 重要性    |
    |------------+-----------|
    | user       | important |
    | author     | important |
    | user       | normal    |
    | author     | normal    |
    | user agent | normal    |
    |------------+-----------|

    很显然，浏览器的默认css定义是不会有important不important的，所以上表只会有5项。这就是按“惯性”推测出来的顺序表，最优先的当然是用户自己标记为important的css规则，最后才是浏览器的默认行为。然而，实际情况却不是这样的。实际情况是：

    | 来源       | 重要性    |
    |------------+-----------|
    | user       | important |
    | author     | important |
    | author     | normal    |
    | user       | normal    |
    | user agent | normal    |
    |------------+-----------|

    可以看到，“author normal”意外的比“user normal”优先。这想想其实是有一定道理的，一个网站应该长什么样子，首先应该是开发者（author）说得算，而不是先由用户说得算。但是，如果用户一定要改变默认的样式，比如增大字体、改变背景等，如果一定要的话，那么还有 "user important" 可以覆盖开发者的默认样式。官方的说法是，这样“达到了一种平衡”，用户应该默认采用开发者的样式，但是用户依然可以“强硬”的更改。我不知道说这些有没有意义，是不是扯太远了，但是对于这种“反常”的东西，我一直认为应该找到其真正的原由，这样才不会觉得规则很“生硬”，很“不知为何？”。那么，现在让我们回过头来，继续讨论“Cascading order”的问题。

    Cascading order的算法是这样的：
    1. 浏览器将所有样式定义，按“来源与重要性”分组。
    2. 根据各组的优先级（上面说到的哪个），取存在的第一优先级的样式规则。如果，用户真的定义了“user important”的样式，那就采用，否则就取下一个，以此类推。
    3. 如果对应分组内的样式有多条，就按 =选择器的特殊性= 排序，采用最特殊的那一条css定义。
    4. 如果那个分组里最特殊的css不只一条，那就取“最晚”定义的那一条css。到这里，就不可能存在多条“最晚定义”的css了！

    为什么会存在选择器特殊性一致的css规则？这很正常，看下css的选择器特殊值如何计算就知道了。


*** Calculating a selector's specificity
    其计算公式为：
    1. 计算id选择器的个数，记为a
    2. 计算类选择器、属性选择器、伪类的个数，记为b
    3. 计算标签选择器、伪元素的个数，即为c
    4. 忽略所有全局选择器

    那么一个选择器的特殊值，S(a, b, c)则为：S(a, b, c) = a * 100 + b * 10 + c

    S(a, b, c)越高，则特殊性越大。
    

*** 依然存在的问题
    上面的Cascading order其实不完备，它没有讲到内联式、行内式、引用式三种css之间的优先级关系，到底哪一种写法的优先级更高？我记得CSS2.1是有讲到的，一时找不到了，当时的笔记也不见了。不过，真要用到的时候，实验一下就能知道了。现在知不知道也无所谓了，等哪天看到了相关的说明再说吧！

* CSS Values
** CSS Length Unit
   CSS的长度单位。这个问题原本只有只有两个重点：1）有哪些长度单位？2）长度单位的继承问题。但是，看到这个单元的时候，我脑袋里闪过了“Retina显示屏模糊”的问题，我很想把这个问题给侬清楚，它貌似跟CSS的“px”很有关系。

*** 长度单位的分类与继承
    CSS的长度单位有两个分类：
    1. 绝对长度：px等;
    2. 相对长度：em、rem、vh/vm、百分比等；

    以上提到的，都是比较常用的长度单位。我们一一讨论一下。

    “像素”，px。这里的px是css概念里的“像素”，不是真实的物理像素。那么css的px有固定的大小吗？W3C给出的答案是，有。约等于0.026厘米。一般浏览器的默认字体是16px，也就是约为0.42厘米，感受一下。但是我怎么觉得实际情况可能未必如此。不过这个目前不用关心。另一个问题是，1px是最小的长度了吗？W3C没给出规范，各个浏览器的规范各异。Safari支持0.5px这样的长度单位，详见这个[[https://codepen.io/benknight/pen/Dwuqk][Example]]。那么还能更小吗？比如0.1px。我想就目前而言，再小应该是不可能的了。按照Retina显示屏，1px的长度相当于2个物理像素点的长度，所以对于Retina显示屏而言，最小单位理论上只能到“0.5px”，即一个“物理像素”。

    再来说明“em”这个单位。它的含义是，1em表示当前元素的字体大小，如果当前元素的字体大小变了，它也就跟着变。所以，它是一个相对长度。所有的“相对长度单位”的区别就在于，参照物不同。这里，把它们一并讲了。见下表：
    | 单位名词 | 参照物                     |
    |----------+----------------------------|
    | em       | 当前元素                   |
    | rem      | root元素，即html元素       |
    | vh       | viewport的高度             |
    | vm       | viewport的宽度             |
    | %        | 看情况，一般情况下是父元素 |
    |----------+----------------------------|

*** Computed Value与继承
    上文提到的相对长度有一个小坑，见这个例子：

    #+BEGIN_SRC web
      <style>
       body {
           font-size: 12px;
           text-indent: 3em;  /* 36px */
       }
       h1 {
           font-size: 15px
       }
      </style>
      <body>
          <h1>Some thing there...</h1>
      </body>
    #+END_SRC

    h1的text-indent到底是多少px呢？是 12px * 3 = 36px，还是15px * 3 = 45px？我们来分析一下。
    h1自己并没有定义text-indent，所以它的text-indent是继承来的(text-indent可被继承)，也就是它继承自父元素body的text-indent。那么是继承“3em”还是继承“3 * 12px = 36px”？
    根据W3C标准可以得到答案，36px。因为W3C的继承，都是继承“Computed Value”，而不是继承“Rule”。所谓Computed Value就是计算之后的结果值。“3em”并不能之间用来渲染，必须转换为确切的值，所以3em的“Computed Value”就是36px，所以h1继承到的text-indent就是36px。
    这就小小的坑了我们一下。比如，上文的text-indent这个属性。我们一般希望每个段落的缩减是“2个字”，所以会定义为“text-indent: 2em;”。但是，如果你只在body定义上定义，而不在实际作用的元素上定义，那么如果两边的字体大小不一致，就会达不到对应的效果。
    
   
*** Retina显示屏模糊问题
    因为自己从未遇到过这个问题，所以我一开始完全摸不着头脑。到底是什么模糊了？字体？border？还是什么？看了一堆文章，一上来就讲“像素密度”什么的，也没说明到底遇到什么问题。直到我看了MDN的这篇文档——[[rmail:https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio][Window.devicePixelRatio]]，才明白问题是什么。噢～ 原来是“位图模糊”问题，而不是什么“border模糊”之类的。是“位图”，“位图”！
    在Retina显示屏出现之前，大部分显示器的1个物理像素与css的1px是相对应的，但是由于Retina显示屏提高了“像素密度”，css的1px对应的却是4个物理像素点。一张位图，最好的效果是，一个“位图像素点”对应一个“物理像素点”来渲染。如果一张图片是200 * 300个像素点，传统情况下，css的设定当然也是200px * 300px了。但是到了Retina屏下，如果依然这样设定，那么其结果是，1个“位图像素点”由4个“物理像素点”来渲染，这样就好像把图片放大了，“颗粒感”也随之出现，也就模糊了。
    解决方案当然是在Retina屏下使用“二倍图”啦。但是这里面涉及到一个图片多版本问题、网络加载问题、开发效率问题、兼容性问题、工程化问题，不是那么简单的。不过这里就不展开讨论了。详见这篇博客——[[https://www.w3cplus.com/css/towards-retina-web.html][走向视网膜（Retina）的Web时代]]，写得不错。

** Specified, computed, used and actual values
   有时候，实在不明白一个css属性为什么要有这么多种“value”。这或许反应了需求的多样性，以及css的复杂性。

   简单来讲，浏览器一开始只需要3种value，我们按它的渲染过程，来逐一讲解。

   1. 渲染的初始阶段，给每个元素的每个css属性一个“Specified Values”，即 =指定值=。算法如下：
      1) 如果定义了css，则采用对应的css值作为Specified Values。
      2) 如果没有定义css并且对应属性是默认继承的，或者定义的css的值就是"inherit"且当前元素存在父元素，则以父元素的Computed Value为本元素的Specified Value。当然，这时候本元素的Computed Value也就等于Specified Value。
      3) 如果即没有定义css，对应属性也不是默认继承的，或者虽然是默认继承的，但是没有父元素（如html），则使用对应属性的“initial value”作为Specified Value。
   2. 确定好Specified Value之后 =正式渲染= 之前，还需要通过Specified Value换算出Computed Value，即 =计算值=。有些值是不利于渲染的，如相对长度单位“em”等。提前将其换算成绝对长度单位“px”，免得渲染时再去做计算，这样可以提高渲染效率。这就是Computed Value的意义所在。另外，属性的继承是按Computed Value作继承的。我想，这同样也是为了提高效率吧！免得逐层作运算。
   3. 最后，来到渲染时，这时候得到的value，就是Used Value，即 =应用值=。为什么要有Used Value？因为Computed Value毕竟是渲染前的值，有些东西是要到渲染的时候才能确认的。比如，有个元素的width: 50%，那么父元素的宽度不知道的时候（因为父元素的宽度可能也是依赖它的父亲元素的，如此逐层往依赖），就计算不出它的宽度。这时候，就非得进行渲染不可！我们需要知道viewport的宽度，然后知道"root"元素的宽度，然后逐层往下渲染。类似的case还有很多，详见[[https://developer.mozilla.org/zh-CN/docs/Web/CSS/used_value][MDN-CSS应用值]]。

   这原本是一个很“美满”的结局。但是，现实世界还真的是复杂的。比如这样一条css： =border: 0.5px solid;=，请问它的 =border-width= 的3 value分别是多少？很显然，3个value都是 =0.5px=。但是实际渲染情况呢？却未必能如愿渲染。Safari在Retina显示屏下能绘制出0.5px宽度的border，而Chrome则会绘制出1px宽度的border。这是“表里不一”啊！css2.1给出了一个新的“value”定义，叫 =actual value=，也就是 =实际值=。 我觉得，这个目前就了解下就好了。因为目前也没有获取Actual Value的js接口，所以即便有这个值存在又如何？Actual Value估计目前只存在于渲染引擎的源码里吧！反倒是Computed Value可以通过 ~window.getComputedStyle~ 这个接口获取，这或许对我们的开发有所帮助。

** CSS Inheritance
   CSS的继承，这里重新梳理一遍要点：
   1. 继承自父元素的Computed Value；
   2. 有些CSS的属性是默认继承自父元素的，另外可以使用'inherit'这个值来强制继承；
   3. 如果元素是根元素，那么“继承”对它来说，会变成使用"initial value"；

   继承采用的是“Computed Value”，会造成一些坑，这里就不再啰嗦了。前面讲过"text-indent: 3em"的例子了。

   其实，这里我最新讨论的是，到底该不该记哪些属性是默认继承的？哪些不是？我在重新学习之前，好像感觉记一下很重要。但是现在想想，却觉得去记哪个会继承哪个不会是很愚蠢的。先不记吧！哪天可能会发现其中的规律。

* Visual Formatting Model
  BFC（Block Formatting Context）与IFC（Inline Formating Context）是CSS两个非常重要的概念。它们的内容主要集中在CSS2.2文档的9、10两章。

** Readding Log
   对于“成果”，我更喜欢了解其达成的 =过程= 、其 =发展的历史= 、存在的 =原因=  ，而不是其本身。阅读 =Visual Formatting Model= 的时候，我希望多记录一些阅读过程中的思考，我称之为日志。

   从Charpter 9开始，就很容易被各种各样的名词、概念搞得糊里糊涂。随便举几个名词吧！
   - Element
   - Box
   - Block
   - Container
   - Line
   - Inline
   - Block Box
   - Inline Box
   - Block-level Block
   - Inline-level Block
   - Containing Block
   - Block Container Box
   - Inline Boxes
   - Line Boxes
   - ... ...

   晕了没有？我自己是晕得不行。读的过程中，貌似有所收获有所理解，但是又理解得不够清晰、深入、完整。脑袋里有了轮廓，但却不清晰。

   这个时候，很自然的就会有一些疑问与思考。我大概更深入的了解到 =Line Boxes= 与 =inline Boxes= 以及 =Inline Formatting Context= 之间的关系，还有大概了解到 =BFC= 与 =IFC= 的关系。我认为，这其中一定有一条很简单的 =概念、规则、或思路= 将这一切串在一起。所以，我的学习思路从 “=阅读= Visual Formatting Model，跟着文档学习”，变成“尝试思考Web的排版系统是怎样的”。这该如何理解？意思就是通过理解“排版系统”，来将那些概念都串起来。
   从上面我列举的名词中，你也看到了，有那么多相似的概念，为什么Web的设计者们要搞得这么复杂？有更简单的方案吗？如果是我，我将怎样设计Web的排版系统？
   思考到这里，我突然意识到，如果去思考一个Web排版系统如何设计、实现，将会对CSS的 =Visual Formatting Model= 有一个很好的理解。我相信会是这样的！

   相比之前看完一章，就能有所收获、理解不同，这一次的学习周期将会更长一些。看第一遍，主要是阅读 + 思考 + 记录疑问 + 记录思考结果，同时要略过琐碎。然后，就是去把 “排版系统” 的实现理清楚。最后，则是重读一遍文档，这一遍带着一个清晰的“排版系统”模型，应该会有更深刻的理解，同时需要拾遗之前忽略的琐碎。

*** 18.10.26
    为什么 Visual Formatting Model有这么多概念？这么复杂？ 可能是因为真的需要
    如果去设计一个“排版系统”需要注意什么方面？Web在最开始的时候，是什么样子的？
    什么是“排版系统”系统？一张白纸+一堆笔，画上文字跟图片？那么粒度是什么？是像素吗？肯定不是，如果是像素，那Web开发者就真的是拿着画纸画笔工作的。
    “粒度”是什么意思的呢？“画画”的粒度？
    把“粒度”在调大一点，如果是“格子”呢？类似网格画布那样。 这样想来，貌似有点接近了。但是，我们不可能一个格子一个格子的去调整格子的“样式属性”，用的时候不可能，开发实现的时候也不可能。比如，“如果”，二字。如果你想让两个字的字体变大，会如何作？我们是一个字一个字的调大小吗？不是！我们是用个"SPAN"或者什么元素，把这两个字“包裹”起来，然后调整字体的大小的。
    怎么样？有没有什么感觉？
    我突然明白，“粒度”指的是“格式化的粒度”，即用户（Web开发者）是如何“使用”的粒度，以及浏览器实现者是如何“实现”的粒度。
    那么，这个“粒度”就不可能是以固定的“格子”为粒度的，我们放开一点，这些“格子”是不是可能是“大小不一”的？貌似是这样的，它的粒度是“大小不一”的格子。格子从左到右（默认）一个一个的排列。
    但是 如果宽度不够呢？换行。“行”跟上面说的“格子”是什么关系？有几种情况：
    1. 一个“格子”可能占很多“行”
    2. 好几个“格子”占一“行”，所以一行会有很多“格子”
    
    “行”，对应的就是Line，按CSS 2.2文档的说法是 =Line Box=
    “格子”，对应的就是InLine Box，按CSS2.2文档的说法也是 =InLine Box=

    按照上面说到的第一点，其实我们的“格子”—— =Inline Box= ，未必 "In Line"。它其实可以是 "Span Lines"。但是为什么依然叫 =InLine Box= ？ 因为它真的是 “In Line”，只不是区别在于“In One Line”，还是“In Many Lines”。也就是说，“格子”总是被“行”包着。

    为什么要先思考只有“文字”的情况？
    其实，我在“假设”的时候、在思考排版系统该如何设计、实现的时候，我觉得先想一个简单的：只能排版文字。不支持图片、不支持其它任务多媒体、不支持浮动（没图片，也就没浮动什么事）、不支持定位、布局。


*** 18.10.27
    经过两天的潜意识思考，我感觉“排版系统”在我脑袋里更清晰一些了。

    等有个更深入的了解之后，是不是可以去阅读一下WebKit关于渲染树、渲染的源码？

    今天进一步的把Normal Flow相关的知识读完，然后是浮动与绝对定位相关的知识，我只是走马观花的看一看。进入我脑中的思考是，CSS如何处理不同“Model”之间的关系的？InLine Box与InLine Box之间什么关系？会有什么作用？InLine Box与Line Box之间呢？Block Box与Line Box之间呢？

    那些属性是Block Box才有的？而哪些是Inline Box才有的？它们之间有什么区别？

    是继续读完Chapter 10 - Visual formatting model detail，还是先理清一遍前面的关系。

    看了一遍网上所说的inline、block、inline-blcok之间的区别，我感觉inline-block或许要跟replaced inline element放在一起讨论，它们可能是一样的。

    现在觉得inline的关键要素在于：1) 元素之间的排列；2）对行高的影响；3）vertical-align。至于inline能不能设置height、width、padding、margin等，则有点混乱。


*** Inline Element
    分析不同display的元素从两个方面入手：
    1. 对内。即元素的大小问题
    2. 对外。与其它不同类型display的元素的相互作用。

    所以，display: inline; 的元素 ，即inline元素由如下特性：
    1. 对内。元素的宽度 = 内容的本来宽度（某些元素可以设定width，但大部分设定width无效） + margin宽度 + padding宽度 + border水平宽度。而元素的高度则根据不同的元素由不同表现，在内容高度方面，或以内容的本来高度为准、或允许设定height属性；在padding与margin方面，或允许设定垂直属性、或不允许。
    2. 对外。分为几个方面：
       1) 排列。Inline元素在同一行从左往右，一个接一个的排列，直到排不下换行。一个行内元素也可能独自占用多行。
       2) 行高。Inline元素的行高，基本取决于自身的line-height属性，但是对于设置height有效的元素（一般是replaced element），则其line-height属性无效，它的真实“line-height”就是“元素本身的高度”！

* Font
** @font-face 之 font-display
  主要感悟来源以下两篇文章:
  - [[https://css-tricks.com/almanac/properties/f/font-display/][font-display | CSS-Tricks]]
  - [[https://developers.google.com/web/updates/2016/02/font-display][Controlling Font Performance with font-display | Google Developers]]

  关于概念，Google开发者那篇讲得很细致了；关于使用，我觉得CSS-Tricks那篇说得比较透彻。

  起源。=font-display=是@font-face的一个属性，为什么需要这个属性？因为@font-face定义的字体往往需要加载，在加载完全之前，文本如何渲染？=font-display=就是用来控制_这段时间_的文本“渲染策略”的。

  有哪些策略？其实无非就两种，“先留白”和“先渲染”。“先留白”就是说，字体文件加载完成前，依赖这个字体的文本先留白，等文件加载完之后再重新渲染。“先渲染”指的是，先使用浏览器端已经有的字体渲染文本，等文件加载完之后再重新渲染。实际上，=font-display= 的取值有很多种，这是因为有一些“混合策略”，我们最后再讨论。先来讨论这两种策略的优点跟缺点。

  “先留白”策略的优缺点。我认为“先留白”是一种“尊重”网站开发者意愿的策略，它保证网站完全按开发者希望呈现给用户的样式来展现。如果网速很快，字体从留白到渲染的间隙非常之短，那么那点留白是时间是不太容易察觉的。这是它的优点。那么如果网速很慢，加载字体需要十几秒，那么这时候就会出现十几秒的文本空白，这种用户体验应该算是很差劲的。这是它的缺点。

  “先渲染”策略的优缺点。与“先留白”相对于的，“先渲染”策略的优点就在于，网速很慢时，它能保证用户先看到文本内容。它的缺点则在于，“不够尊重开发者”。其实这并不是什么大不了的缺点，我相信有严格保证呈现给用户字体样式要求的网站还是少的，真正的缺点在于：如果网速很快，渲染引擎也给力（一般都给力），那么文本几乎立即被渲染出来（这时候是用“备用字体”），紧接着字体文件也加载完毕（因为网速很快），那么文本又会立即被渲染一次（这次是使用@font-face定义的字体）。这种情况，就会造成文本区“闪烁”一下，网络称之为FOUT--"Flash of Unstyled Text"。这才是它的真正缺点。

  我们该使用什么策略？其实决定权往往不再开发者，或者用户手里，决定权在“网络质量”手里。如果网络条件很好，用“先留白”；如果网络条件很差，用“先渲染”。为此，=font-display=才有了=fallback=跟=optional=这两个值，它们代表“先留白”跟“先渲染”两种策略的“混合策略”。也就是，先采用很短的“先留白”策略，一般是100ms，如果网速很好100ms也够下载字体了；如果100ms还没下载完字体，那么立即采用使用备用字体渲染文本，直到字体加载完毕。

  没有完美的策略。其实，不管哪一种方案都很难避免“闪烁”的发生。因为网络不是简单的只有“很好”跟“很坏”之间，100ms的时候还没加载完毕，但是110ms的时候就加载完毕了，这时候就要在10ms内经历“空白”->“备用字体渲染”->“期望字体渲染”的多重闪烁，哈哈哈～
  
* font-display与loading组件的相互借鉴。
  在使用Loading效果的时候，遇到一些问题，今天重读font-display的时候发现两者有可以相互借鉴的地方。

  先说Loading的问题。当组件正在加载数据的时候，我们希望组件显示一个loading效果，等数据加载完成后，再去掉loading效果。这会有这样的问题：当数据加载非常快的时候，从loading -> 取消loading的过程会非常的快，这时候会组件闪烁一下，很影响体验。

  怎么解决？这时候需要在进入loading以及退出loading的时候加上过渡动画，这样就会顺滑一些。

  但是如果数据加载非常快，这时候还要进入loading，不免让人心烦，总是要等那么久。我觉得这时候就可以采用font-display的混合策略，即：
  1. 组件直接白屏，并且等待100ms
  2. 如果100ms内数据还没有加载到，则进入loading效果
  3. 等到数据加载到之后，使用过渡动画退出loading

  这样就能比较完美的解决上诉体验问题。当然，如果能像font-display那样考虑网络情况，那就更牛皮了～

  反过来，loading的过渡动画也可以借鉴给font-display。font-display虽然有机制可以大概率避开字体变化时产生的闪的问题，但是却无法避免。如果新字体加载到之后，那么也使用过渡动画切换字体，这样是不是也就顺滑了很多？但是，想想也知道字体貌似不支持动画，并且这样很有可能会有性能问题。


  
* 从 =text-overflow: ellipsis= 到 =white-space=
  从=text-overflow: ellipsis=开始讨论。

  “超出的文本变成省略号”，是很常见的UI需求。怎么做呢？
  1. 首先，你要让文本“超出(overflow)”
  2. 其次，设置=text-overflow: ellipsis=, =overflow: hidden=
  
  第一点不是那么容易做到。你需要有如下两个条件：
  1. 首先，你的容器要有一个 =“宽度”= ，否则就很难“超出”；
  2. 其次，你要打破浏览器的一个默认行为—— =文本自动换行=,  需要设置属性 =white-space: nowrap=

  所以合起来就是三步走：
  1. 首先，检查容器是不是有一个宽度，或者最大宽度
  2. 其次，让文本不换行 —— =white-space: nowrap=
  3. 最后，设置=text-overflow: ellipsis=, =overflow: hidden=


  对=white-space=的疑问

  这里，让我好奇的属性是 =white-space: nowrap=。为什么控制文本是否换行的属性名字叫做=white-space=？这看起来很不合理，叫=line-wrap=不是更好？查了一下属性说明，发现了一点其中的渊源。

  这个渊源就是HTML对空格的处理问题。HTML是这样对待文本中的空格的：
  1. 忽略文本的前置、后置空白字符；
  2. 文本中间连续的空白字符只会当作一个“空格”；
  请特别注意“空白字符” 与 “空格”。

  现实的需求是多样的，浏览器这样粗暴的对待文本中的空白字符有点过于粗暴和不近人情。于是有了 =<pre>= 这个标签，它会渲染所有空白字符，“原样”输出文本。

  现实是无奈的，你以为有了=<pre>=真的就能“原样”输出了吗？不是的，“换行问题”也来瞎搅和。诚然，在=<pre>=我们可以通过换行符来控制换行，但是如果一行的文本太长超出容器宽度了，换还是不换呢？你要“原样输出文本”，那就不换，但是这样文本又溢出到容器之外；如果换行了，又不是“原样输出”了。这种case，默认情况下，其它标签是换行的，=<pre>=标签是不换行的。

  梳理一下，这里面有两个方面的问题：
  1. 如何处理空白字符？有如下选项
     1) 走浏览器默认行为：忽略文本前后空白字符，文本中间连续空白字符当作一个空格。
     2) 不做特殊处理
     3) 遇到换行符则换行，其它字符依然走浏览器默认行为 
  2. 一行文本太长，要不要换行？
     1) 不换行
     2) 换行

  我觉得，=white-space= 其实只应该考虑第一个方面的问题，而第二方面的问题应该另起一个新属性，例如=line-wrap=来处理。但是，它把这两方面的问题都考虑了，这是我觉得它畸形、奇怪的地方。我们把这两个维度做一个排列组合：
  | 如何处理空白字符？                             | 一行文本太长，要不要换行？ | 对应=white-space=属性值 |
  |------------------------------------------------+----------------------------+-------------------------|
  | 浏览器默认行为                                 | 换行                       | normal                  |
  | 浏览器默认行为                                 | 不换行                     | nowrap                  |
  | 不做特殊处理                                   | 不换行                     | pre                     |
  | 不做特殊处理                                   | 换行                       | pre-wrap                |
  | 遇到换行符则换行，其它字符依然走浏览器默认行为 | 换行                       | pre-line                |
  | 遇到换行符则换行，其它字符依然走浏览器默认行为 | 不换行                     | 不存在                  |
  |------------------------------------------------+----------------------------+-------------------------|
* 让"to-do"不在"-"处断词。
  默认情况下，断词规则是=word-break=的，但是遇到'-'的时候浏览器会允许断词。英语中'-'其实有两个作用：
  1. 断词。即行末写不下某个单词了，要把单词拆开到两行写，则要以'-'结尾，表示这里断词了。
  2. 连词。某些单词是由两个单词连在组成的，如=to-do=。

  很显然，当一个词是连词的时候，'-' 又不小心被当作断词符了，那么可能会引起歧义。当你认为它是断词符号的时候，"to-(第一行行尾巴)do(第二行行首)" 就变成了"todo"，而实际上你希望它被视为“to-do”（ps. 虽然这里"todo"与“to-do”并无二意）。这个时候浏览器希望你告诉它，'-'是连词符号，请不要以它为断词符，以免引起歧义。你只需要把'-'改成=&#8209;=即可。

  这个特殊符号叫[[https://en.wikipedia.org/wiki/Wikipedia:Nonbreaking_hyphen][Nonbreaking hyphen]]。
* non-breaking space与一个设计原则
  今天我才知道一直算是“误解”了一个特殊符号=&nbsp;=。以前我一直以为它是“空格”的转义字符，实际上这个定义不准确，准确的定义是--"Non-breaking space"。因为一般的空格可以被断行的，只要换成这个"Non-breaking space"，浏览器就不会在此处断行。虽然说它也可以用来产生“多个空格”，但是更高级的用法是防止最后一行只有一个单词。
  “最后一行不要只有一个单词”，这是designer告诉我的，我觉得很合理。如果只有一个单词，总觉得“多余”、不完美。所以，完美一点的做法是把最后一个“空格”替换成“不断行空格”，这样强行让浏览器最多只能在倒数第二个空格处断行，从而避免一个单词一行的情况。
* AOS animation on-scroll
  [[%E4%BC%A0%E9%80%81%E9%97%A8][https://michalsnik.github.io/aos/]]
  这个库不错
* animation的timing function
  这两天回头看css的animation，对animation-time-function有点不太理解，这里记录一下自己的探索过程。
  所谓animation，就是随着时间推移而变化的“图”。所以，你要定义一个动画，就需要定义如下两个关键内容：
  1. 多长的时间？
  2. 不同时间段内，画面的状态如何？

  =animation-duration= 用来定义多长时间，而=@keyframes=则用来定义不同时间段内，元素的样式如何。所以，我实在不懂，为什么还需要=animation-timing-function=？它有什么作用？
  简单来讲，这个时间函数是个二维曲线，x代表时间，而y代表动画进行的“进度”。也就是说，它允许你控制“随着时间的推移，动画的播放进度如何”。怎么理解呢？为什么会有这种需求？

  我们先来说说怎么理解，但是在说之前，我先说下上面所说的那个“曲线”、“x”、“y”。打开chrome的devtool，找到有动画的那个元素，然后搜索到它的=animation-timing-function=属性，是不是
会看到一个波浪图标？点开它，你就看到我所说的二维曲线了。 你会发现，这个曲线在画面可见的范围内，x、y的取值都在[0, 1]。你可以摆弄一下，有两个点可以拖动。然后我们进入正题。

  先说进度。所有的动画进度都会被归一化为，用100%来表示，其实=@keyframes=就是做了这件事情，看个=@keyframes=都例子：
  #+BEGIN_SRC css
    @keyframes sun-goes-down {
            0% {
                    background: #F57209;
                    transform: rotate(-70deg);
            }

            30% {
                    background: #FFEF00;
                    transform: rotate(-28deg);
            }

            70% {
                    background: #FFEF00;
            }

            100% {
                    background: #F57209;
                    transform: rotate(70deg);
            }
    }
  #+END_SRC
  是不是很直观？

  假设动画持续了=1s=，那么=0.3s=的时候，就应该刚好对应=30%=里的样式，而=1s=的时候，应该刚好对应=100%=里的样式，对不对？不太对。因为一个动画，进行到某个时间点，其进度如何，是
由=animation-timing-function=控制的。可以试试把一个动画的=animation-timing-function=赋值为=cubic-bezier(0.59,-0.35, 0.23, 1.15)=，你会发现，这个动画播放的时候“回光反照”了。

  那为什么会有这种需求呢？直觉上，我觉得还是挺正常的吧，增加你对动画的控制能力。至于更深层次的原因，我也没什么思路。
* offsetTop与offsetParent
  =$el.offsetTop=并一定不是元素的顶部到body顶部的距离，而是到=$el.offsertParent=的距离。所谓=$el.offsetParent=也就是最近的一个相对定位的容器元素。

  所以，如果你要获取一个元素顶部到body顶部的距离，那就需要通过=offsetParent=一层一层递归下去，把每一层的=offsetTop=也累加起来才行。

  这里有个点要注意：offsetTop是不会以=transform=之后的位置为准的，所以如果你发现得到的=offsetTop=不“准确”，那你要看看元素是不是被=transform=了。
* 字体对齐问题 -- how to compute inline element height
  今天遇到一个字体对齐问题，使我对=height=有一个更深入的认识。
  先前就已经知道，block element的height如果是auto的时候，其computed height的计算方式是：max(computed line-height of inner inline element)。现在公司使用的字体是ProximaNova，它渲染出来的inline element的height刚刚好就是赋予的font-size。这使我有2个错误的认识：
  1. 我以为所有的inline element的height就应该等于font-size
  2. 在处理一些字对齐的问题的时候，经常使用line-height=1，然后height与computed line-height刚好相等，这让我以为inline element height与line-heigth就是同一个东西

  先描述一下今天做的题目，写一个天气预报的界面（[[file:attachments/compute-inline-element-height.webarchive][web archive]]），我在处理底部的“温度”与“风向”、“湿度”的对齐问题的时候陷入了困境。温度的font-size为45px，然后“风向”的顶部要与“温度”的顶部对齐，“风向”的底部要与“湿度”的底部对齐。我一开始以为用个grid布局（如我css所写），并且所有line-height都设置为1，然后“风向”与“湿度”各自的align-self分别为start跟end就能很完美的解决这个问题了。

  结果让我大跌眼镜。非常的不对齐，我给温度里面的文本包个span，从dev tools看到它的高度竟然是61px（使用'Open Sans'字体时）。由于之前经验的误导，我一时陷入了迷茫，我以为是自己乱秀grid布局导致的问题。然后，我脱离grid布局，写了个span，发现高度还是61px。最后，Google了一下，才发现之前的认识是错误的。

  首先，=height of inline element= 与=inline-height of inline elment=是完全不一样的概念！虽然，那个span的height是61px，但是它的computed inline-height依然是45px * 1，所以包裹它的div的高度也是45px。

  其次，=height of inline element=并不一定会等于font-size，css2.2里有说，见[[https://www.w3.org/TR/CSS22/visudet.html#inline-non-replaced][文档]]。它根本不受css标准控制，不同的字体会渲染出不同的结果。我在那个web archive文件里上面写了好几个font-size为45px的span，每个span字体不同，它们的height也完全不一样，有的61px，有的51px，有的刚好等于45px。

  最后，=height of inline element=非常大概率下是不等于实际渲染出来的字的高度。所以，如果两列字的font-size差很大，你还想让它们水平对齐，那只能比较hack的的方式去微调了，比如用margin或者绝对定位，[[file:attachments/hack-adjust-vertical-align.png][如图]]。
